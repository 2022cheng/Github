#include<stdio.h>
#include<stdlib.h>
#define OK 1
#define ERROR 0
typedef int Status;
typedef float ElemType;
typedef struct LNode{
    ElemType data;
    LNode *next;
}LNode , *LinkList;
//或者可以这样写
/*struct LNode{
    ElemType data;
    struct LNode *next;
};
typedef struct LNode LNode;
typedef LNode *LinkList;*/

//创建的单链表，头插法
void CreatList_L(LinkList &L,int n) //输入n个元素的值
{
    LNode *p;  int i;
    L=(LinkList)malloc(sizeof (LNode));
    L->next=NULL;  //先建立一个带头结点的空链表
    for(i=n;i>0;--i)
    {
        p=(LinkList)malloc(sizeof (LNode));
        scanf("%f",&p->data);   //已经带了输入，所以在主函数里面不要再写输入数据
        p->next=L->next;
        L->next=p;
    }
}
//尾插法
void CreateListTail(LinkList &L,int n)
{
    LinkList  r=L=(LinkList)malloc(sizeof (LNode));
    L->next=NULL;
    for(int i=1;i<=n;++i)
    {
        LinkList s=(LinkList) malloc(sizeof (LNode));
        scanf("%f",&s->data);
        s->next=NULL;
        r->next=s;
        r=s;
    }
}
//单链表的插入
int Listlnsert_L(LinkList &L, int i, ElemType e)
{     //带头结点的单链表L中第i个位置之前插入元素e
    LNode *p,*s;
    int j=0;
    p=L;
    while(p&&j<i-1)
    {
        p=p->next;  ++j;
    }
    if(!p || j>i-1) return ERROR;
    s=(LinkList)malloc(sizeof(LNode));  //生成新的结点
    s->data=e;         //使新结点数据域的值为e
    s->next=p->next;    //将新结点插入到弹量表L中
    p->next=s;       //修改第i-1个结点指针
    return OK;
}
//取第i个元素
Status GetElem_L(LinkList L,int i,ElemType &e)
{   //L是带头节点的链表的头指针，以e返回第i个元素
    LNode *p;  int j=1;  //j是计数器
    p=L->next;
    while(p && j<i)
    {
        p=p->next;    ++j;
    }
    if(!p||j>i)
        return ERROR;
    e=p->data;
    return OK;
}
//单链表的删除
int ListDelete_L(LinkList &L,int i,ElemType &e)
{   //删除第i个元素，并由e返回其值
    LNode *p, *q;
    int j = 0;
    p = L;
    while (p->next && j < i - 1) {
        p = p->next;
        ++j;
    }
    if (!(p->next) || j > i - 1) return ERROR;   //删除位置不合理
    q = p->next;  //用指针q指向被删除的结点
    p->next = q->next;  //删除第i个结点
    e = q->data;     //取出第i个结点的数据域值
    free(q);      //释放第i个结点，避免出现空姐点
    return OK;
}
void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc)
// 或者void MergeList_L(LinkList La,LinkList Lb,LinkList Lc)
{    //归并La和Lb得到新的单链表Lc,Lc的元素也按非递减排列
    LNode *pa,*pb,*pc;
    pa=La->next;  pb=Lb->next;
    Lc = pc = La;   //用La的头节点作为Lc的头节点
    while(pa && pb)
    {
        if(pa->data<=pb->data)
        {    //如果pa->data<=pb->data
            pc->next=pa;    pc=pa;   pa = pa->next;
        }
        else{
            pc->next=pb;  pc=pb;   pb = pb->next;
        }
        pc->next = pa?pa:pb;  //插入剩余段
        free(Lb);
    }
}
//单链表的输出
void List_printf(LinkList &L)
{
    LNode *p=L->next;
    while(p) {
        printf("%f ", p->data);   //输出插入的元素
        p=p->next;
    }
}
//求最大值 
Status Max(LinkList L)
{
    LNode *p;
    LinkList max;
    max=p=L->next;
    while(p)
    {
        if(max->data<p->data)
        {
           max=p;
        }else {p=p->next;}
    }
    printf("最大值为：%f",max->data);
}
int main()
{
    int i,j;
    LinkList LA,LB,LC;
    ElemType a,b,e;
    scanf("%f",&a);    //创建的单链表的长度
    CreatList_L(LA, a);    //创建一个单链表
   /* scanf("%f",&b); //插入链表中的元素个数
    scanf("%d",&i);  //插入位置
       for(j=0;j<b;j++) {    //插入的元素
           scanf("%f", &e);
           Listlnsert_L(LA, i, e);
       }
    List_printf(LA);
    LNode *p=LA->next;    //或者写LinnkList p=L->next;
    while(p)  // 或者while(p!=NULL)
    {
        printf("%f ", p->data);   //输出插入的元素
        p=p->next;
    }   //此方法为链表的输出方法    */
    printf("\n");
    printf("输入要查找的元素：");
    scanf("%d",&i);
    GetElem_L(LA,i,e);
    printf("查找的第%d个元素是%f\n",i,e);
    printf("输入要删除的元素位置");
    scanf("%d",&i);
    ListDelete_L(LA,i,e);
    printf("删掉的元素是%f",e);
    printf("\n");
    scanf("%f",&a);    //LB的链表长度
    CreateListTail(LB, a);   //用尾插法创建单链表LB
    printf("输出单链表LB\n");
    List_printf(LB);
    printf("\n");
    printf("输出归并后的单链表LC\n");
    MergeList_L(LA,LB,LC);
    List_printf(LC);
    Max(LA);

    return 0;
}
